# ==============================================================================
# Fat-arrow functions without parameters.
# ==============================================================================
Given javascript (fat-arrow function without parameters):
  () => {}

Do (trigger doge):
  \<C-d>

Expect javascript (generated comment with @description @function tags):
  /**
   * @description TODO
   * @function
   */
  () => {}

# ==============================================================================
# Fat-arrow functions with parameters without type hints.
# ==============================================================================
Given javascript (fat-arrow function with parameters without type hints using 'const' and 'let' declarations):
  const myFunc = ($arg1 = 'value', arg2 = [], arg3, arg4) => {}

  let myFunc = ($arg1 = 'value', arg2 = [], arg3, arg4) => {}

Do (trigger doge):
  \<C-d>
  :11\<CR>
  \<C-d>

Expect javascript (generated comment with @description, @function and @param tags):
  /**
   * @description TODO
   * @function myFunc
   * @param {*} $arg1 - TODO
   * @param {*} arg2 - TODO
   * @param {*} arg3 - TODO
   * @param {*} arg4 - TODO
   */
  const myFunc = ($arg1 = 'value', arg2 = [], arg3, arg4) => {}

  /**
   * @description TODO
   * @function myFunc
   * @param {*} $arg1 - TODO
   * @param {*} arg2 - TODO
   * @param {*} arg3 - TODO
   * @param {*} arg4 - TODO
   */
  let myFunc = ($arg1 = 'value', arg2 = [], arg3, arg4) => {}

# ==============================================================================
# Fat-arrow functions with parameters with type hints.
# ==============================================================================
Given javascript (fat-arrow function with parameters with type hints):
  const myFunc = ($arg1: string = 'value', arg2: string[] = [], arg3: number, arg4: float): string[]  {}

Do (trigger doge):
  \<C-d>

Expect javascript (generated comment with @description, @function, @param and @return tags):
  /**
   * @description TODO
   * @function myFunc
   * @param {string} $arg1 - TODO
   * @param {string[]} arg2 - TODO
   * @param {number} arg3 - TODO
   * @param {float} arg4 - TODO
   * @return {string[]} TODO
   */
  const myFunc = ($arg1: string = 'value', arg2: string[] = [], arg3: number, arg4: float): string[]  {}

# ==============================================================================
# Fat-arrow functions with destructuring.
# ==============================================================================
Given javascript (fat-arrow functions with destructuring):
  class Test {
    myMethod = ({ b: number }) => {
      return this.add(b);
    }

    myMethod({ b: number }): number {
      return this.add(b);
    }
  }

Do (trigger doge):
  :2\<CR>
  \<C-d>
  :11\<CR>
  \<C-d>

Expect javascript (generated comments with @description, @function, @param and @return tags):
  class Test {
    /**
     * @description TODO
     * @function myMethod
     * @param {number} b - TODO
     */
    myMethod = ({ b: number }) => {
      return this.add(b);
    }

    /**
     * @description TODO
     * @param {number} b - TODO
     * @return {number} TODO
     */
    myMethod({ b: number }): number {
      return this.add(b);
    }
  }

# ==============================================================================
# Fat-arrow functions with a specific scope.
# ==============================================================================
Given javascript (fat-arrow function with a specific scope):
  class Test {
    myMethod(public b: number) {
      return this.add(b);
    }
  }

Do (trigger doge):
  :2\<CR>
  \<C-d>

Expect javascript (generated comment with @description and @param tags):
  class Test {
    /**
     * @description TODO
     * @param {number} b - TODO
     */
    myMethod(public b: number) {
      return this.add(b);
    }
  }

# ==============================================================================
# Prototype fat-arrow functions with parameters with type hints.
# ==============================================================================
Given javascript (prototype fat-arrow function with parameters with type hints):
  Person.prototype.greet = (arg1: string = 'default', arg2: Immutable.List = Immutable.List()): string[] => {};

Do (trigger doge):
  \<C-d>

Expect javascript (generated comment with @description, @function, @param and @return tags):
  /**
   * @description TODO
   * @function Person#greet
   * @param {string} arg1 - TODO
   * @param {Immutable.List} arg2 - TODO
   * @return {string[]} TODO
   */
  Person.prototype.greet = (arg1: string = 'default', arg2: Immutable.List = Immutable.List()): string[] => {};

# ==============================================================================
# Prototype fat-arrow functions with parameters without type hints.
# ==============================================================================
Given javascript (prototype fat-arrow function without parameters without type hints):
  Person.prototype.greet = () => {};

Do (trigger doge):
  \<C-d>

Expect javascript (generated comment with @description and @function tags):
  /**
   * @description TODO
   * @function Person#greet
   */
  Person.prototype.greet = () => {};

# ==============================================================================
# Fat-arrow functions with parameters with multiple type hints.
# ==============================================================================
Given javascript (fat-arrow function with parameters with multiple type hints):
  const myFunc = ($arg1: string, arg2: Foo | Bar | Baz): (Foo | Bar) => {};

Do (trigger doge):
  \<C-d>

Expect javascript (generated comment with @description, @function, @param and @return tags):
  /**
   * @description TODO
   * @function myFunc
   * @param {string} $arg1 - TODO
   * @param {Foo|Bar|Baz} arg2 - TODO
   * @return {Foo|Bar} TODO
   */
  const myFunc = ($arg1: string, arg2: Foo | Bar | Baz): (Foo | Bar) => {};
